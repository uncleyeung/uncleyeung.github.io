<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>uncleyeung&#39;s blog_uncleyeung</title>
  
  <subtitle>uncleyeung.github.io</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="uncleyeung.github.io/"/>
  <updated>2018-03-10T06:38:20.000Z</updated>
  <id>uncleyeung.github.io/</id>
  
  <author>
    <name>杨 博</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RESTful-Operating 2</title>
    <link href="uncleyeung.github.io/2018/03/10/RESTful-Operating2/"/>
    <id>uncleyeung.github.io/2018/03/10/RESTful-Operating2/</id>
    <published>2018-03-10T06:23:32.000Z</published>
    <updated>2018-03-10T06:38:20.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/web/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS-Windows-macOS-and-Linux-app-amp-kernel-driver-dev-Patches-x86-64-assembly-on-the-side-Comp-Sci-Student"><a href="#作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS-Windows-macOS-and-Linux-app-amp-kernel-driver-dev-Patches-x86-64-assembly-on-the-side-Comp-Sci-Student" class="headerlink" title="作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS, Windows, macOS and Linux app &amp; kernel driver dev. Patches x86_64 assembly on the side. Comp Sci Student"></a>作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS, Windows, macOS and Linux app &amp; kernel driver dev. Patches x86_64 assembly on the side. Comp Sci Student</h2><h3 id="TWITTER"><a href="#TWITTER" class="headerlink" title="TWITTER"></a><a href="https://twitter.com/uncleyeung" target="_blank" rel="noopener">TWITTER</a></h3><h6 id="4-Consumes和-Produces的区别："><a href="#4-Consumes和-Produces的区别：" class="headerlink" title="4.Consumes和@Produces的区别："></a>4.Consumes和@Produces的区别：</h6><p>​    1.@Consumes是用来标记一个资源可接受的请求的类型；@Produces用来标记一个资源产出的类型;</p><p>​    2.@Consumes对应的是请求头中的Content-Type；@Produces对应的是请求头中的Accept；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//针对不同的请求格式返回不同的数据格式</span></span><br><span class="line"><span class="comment">//headers="Accept=application/xml",代表请求头中有Accept=application/xml的请求</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emps"</span>,prouces=<span class="string">"aaplication/xml"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getExpXML</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"获取XML格式数据"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/emps"</span>,headers=<span class="string">"Accept=application/json"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getExpJSON</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"获取Json格式数据"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><p>使用Ajax来发送各种请求方法的请求；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:"/job/id",</span><br><span class="line">type:"DELETE",</span><br><span class="line">dataType:"json",</span><br><span class="line">success:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以使用过滤器对请求方法进行修改：<br>1，在请求中使用<strong>_method</strong>=DELETE来提交请求方法；<br>2，使用SpringMVC提供的org.springframework.web.filter.HiddenHttpMethodFilter转化</p><p>注意form表单的提交方式必须是post,因为过滤其会判断是不是post,是post才会对请求方式进行处理,过滤器中会调用一个继承了HttpServlerRequestWapper请求包装类,把我们设定的_method的请求方法对请求方式进行包装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--　浏览器不支持put,delete等method,由该filter将/blog?_method=delete转换为标准的http　delete方法　--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置参数名称，默认是_method--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>methodParam<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>_httpmethod<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>HiddenHttpMethodFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="RESTFUL最佳实践"><a href="#RESTFUL最佳实践" class="headerlink" title="RESTFUL最佳实践"></a>RESTFUL最佳实践</h3><p>​    版本:更新的时候,保证老版本的路劲同样可以访问,明确的提示给老版本用户新版本发布的消息,监控老版本路径,确定没人使用了,再取消</p><p>​    RESTFUL的api最好做到Hipermedia模式</p><p>​    根路径:一般根路径会单独使用一个二级域名,在根路径下面放好API,</p><p>​    数据过滤:让查询返回的数据有数量的限制</p><p><strong>登陆</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/login/token"</span>)</span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">TokenRestController</span></span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(method=<span class="string">"RequestMethod.POST"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> JsonResult <span class="title">creatToken</span><span class="params">(String name,String psssword,HttpServletRequest request)</span></span></span><br><span class="line"><span class="function">LogInfo loginfo</span>=           loginService.login(name,psssword,request.getreomteAdder)</span><br><span class="line">      <span class="keyword">if</span>(loginfo!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">//登陆成功,生成一个token,放到JsonResult中</span></span><br><span class="line">      &#125;</span><br><span class="line">  ...&#125;</span><br></pre></td></tr></table></figure><p>HanderMenthodArgumentResolver方法参数处理器接口,会尝试帮我们注入controller中的参数的类,通过实现这个类,可以注入很controller共同需要的参数.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line">  <span class="comment">//参数符合哪些条件的参数需要这个类来处理,把相关参数打包为MethodParameter对象</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter var1)</span></span>;</span><br><span class="line"><span class="comment">//处理参数</span></span><br><span class="line">    <span class="function">Object <span class="title">resolveArgument</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      //要处理的参数</span></span></span><br><span class="line"><span class="function"><span class="params">      MethodParameter var1, </span></span></span><br><span class="line"><span class="function"><span class="params">      //modelAndView的上下文</span></span></span><br><span class="line"><span class="function"><span class="params">      ModelAndViewContainer var2, </span></span></span><br><span class="line"><span class="function"><span class="params">      //要处理的请求</span></span></span><br><span class="line"><span class="function"><span class="params">      NativeWebRequest var3, </span></span></span><br><span class="line"><span class="function"><span class="params">      WebDataBinderFactory var4)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 专门用于处理controller方法中的参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">""</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerMethodArgumentResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter methodParameter)</span> </span>&#123;</span><br><span class="line"><span class="comment">//判断methodParameter是不是我们要的参数逻辑</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer, NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//是我们需要的参数时候的处理逻辑,并返回处理之后的参数</span></span><br><span class="line"><span class="keyword">return</span> xxx;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/web/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;作為一個人，要有獨立的思想和角
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RESTful-Operating 1</title>
    <link href="uncleyeung.github.io/2018/03/10/RESTful-Operating1/"/>
    <id>uncleyeung.github.io/2018/03/10/RESTful-Operating1/</id>
    <published>2018-03-10T05:50:37.000Z</published>
    <updated>2018-03-10T06:37:29.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/web/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS-Windows-macOS-and-Linux-app-amp-kernel-driver-dev-Patches-x86-64-assembly-on-the-side-Comp-Sci-Student"><a href="#作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS-Windows-macOS-and-Linux-app-amp-kernel-driver-dev-Patches-x86-64-assembly-on-the-side-Comp-Sci-Student" class="headerlink" title="作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS, Windows, macOS and Linux app &amp; kernel driver dev. Patches x86_64 assembly on the side. Comp Sci Student"></a>作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS, Windows, macOS and Linux app &amp; kernel driver dev. Patches x86_64 assembly on the side. Comp Sci Student</h2><h3 id="TWITTER"><a href="#TWITTER" class="headerlink" title="TWITTER"></a><a href="https://twitter.com/uncleyeung" target="_blank" rel="noopener">TWITTER</a></h3><h3 id="rest的历史"><a href="#rest的历史" class="headerlink" title="rest的历史"></a>rest的历史</h3><p>​    http1.0主要面向静态文档开发.rest是一种架构理论,http1.1协议是一种实现了rest的一种协议,rest高于http1.1</p><h3 id="rest的核心"><a href="#rest的核心" class="headerlink" title="rest的核心"></a>rest的核心</h3><h6 id="1-Resources-资源"><a href="#1-Resources-资源" class="headerlink" title="1.Resources(资源)"></a>1.Resources(资源)</h6><p>​    是网络上的一个实体或者一个具体的信息,可以使用一个URI指向它,每个资源对应一个特定的URI.要获取他,只要访问它的URI就可以了</p><h6 id="2-Representation-表现层"><a href="#2-Representation-表现层" class="headerlink" title="2.Representation(表现层)"></a>2.Representation(表现层)</h6><p>​    我们把资源具体呈现出来的形式,就叫做表现层,URI只代表”资源”的位置,他的具体表现形式,应该是在Http请求头中从Accept和Content-Type字段指定.</p><h6 id="3-State-Transfer-状态转化"><a href="#3-State-Transfer-状态转化" class="headerlink" title="3.State Transfer(状态转化)"></a>3.State Transfer(状态转化)</h6><p>​    Http是一个无状态协议,这意味着所有的状态都必须保存在服务器端,因此必须通过某种手段让服务器端发生”状态转化”.这种转化是建立在表现层之上.</p><h6 id="4-Uniform-Interface-统一接口"><a href="#4-Uniform-Interface-统一接口" class="headerlink" title="4.Uniform Interface(统一接口)"></a>4.Uniform Interface(统一接口)</h6><p>​    统一接口,rest要求必须通过统一的接口来对资源执行各种操作</p><h6 id="5-RESTFUL架构-按照REST架构设计出来的就是RESTFUL"><a href="#5-RESTFUL架构-按照REST架构设计出来的就是RESTFUL" class="headerlink" title="5.RESTFUL架构(按照REST架构设计出来的就是RESTFUL)"></a>5.RESTFUL架构(按照REST架构设计出来的就是RESTFUL)</h6><p>​    1.每一个URI代表一种资源</p><p>​    2.客户端和服务器之间,传递这种资源的某种表现层</p><p>​    3.客户端通过Http提供的统一接口</p><h3 id="系统的接口"><a href="#系统的接口" class="headerlink" title="系统的接口"></a>系统的接口</h3><p>把系统中服务作为接口暴露出去,一般分为公共接口和私用接口,常用的接口方式:</p><p>1.WebService,</p><p>2.普通的HTTP请求(一般返回json或者xml),</p><p>3.RPC(远程过程调用),不适合对外接口调用</p><h3 id="RESTFUL设计"><a href="#RESTFUL设计" class="headerlink" title="RESTFUL设计"></a>RESTFUL设计</h3><h6 id="1-资源设计"><a href="#1-资源设计" class="headerlink" title="1.资源设计"></a>1.资源设计</h6><p>​    1.每一个网址代表一种资源,所有网址中不能有动词,而且所用的名词往往与数据库的表格名对应</p><h6 id="2-动作设计"><a href="#2-动作设计" class="headerlink" title="2.动作设计"></a>2.动作设计</h6><p>​    1.Http动作</p><p>​    GET（SELECT）：从服务器取出资源（一项或多项）。<br>​    POST（CREATE）：在服务器新建一个资源。<br>​    PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。<br>​    PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性【补丁】）。<br>​    DELETE（DELETE）：从服务器删除资源。</p><p>​    HEAD：获得一个资源的元数据，比如一个资源的hash值或者最后修改日期；<br>​    OPTIONS：获得客户针对一个资源能够实施的操作；</p><p>​    2.动作示例</p><p>​    GET /zoos：列出所有动物园<br>​    POST /zoos：新建一个动物园<br>​    GET /zoos/ID：获取某个指定动物园的信息<br>​    PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）<br>​    PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）<br>​    DELETE /zoos/ID：删除某个动物园<br>​    GET /zoos/ID/animals：列出某个指定动物园的所有动物<br>​    DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</p><h6 id="3-返回结果"><a href="#3-返回结果" class="headerlink" title="3.返回结果"></a>3.返回结果</h6><p>​    1.返回值类型</p><p>​    GET /collection：返回资源对象的列表（数组）<br>​    GET /collection/resource：返回单个资源对象<br>​    POST /collection：返回新生成的资源对象<br>​    PUT /collection/resource：返回完整的资源对象<br>​    PATCH /collection/resource：返回完整的资源对象<br>​    DELETE /collection/resource：返回一个空文档</p><p>​    2.ContentType</p><p>​    1，一个API可以允许返回JSON，Xml甚至HTML等文档格式；建议使用json；<br>​    2，可以通过URL来规定获取得格式类型，比如<a href="https://api.example.com/v1/employee/1.json等；但是更建议使用Accept" target="_blank" rel="noopener">https://api.example.com/v1/employee/1.json等；但是更建议使用Accept</a> type这个请求头；<a href="https://api.example.com/v1/employee/1" target="_blank" rel="noopener">https://api.example.com/v1/employee/1</a></p><p>​    3.常见状态码</p><p>​    200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</p><p>​    201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。<br>​    202 Accepted - [<em>]：表示一个请求已经进入后台排队（异步任务）<br>​    204 NO CONTENT - [DELETE]：用户删除数据成功。<br>​    400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操        作是幂等的。<br>​    401 Unauthorized - [</em>]：表示用户没有权限（令牌、用户名、密码错误）。<br>​    403 Forbidden - [<em>] 表示用户得到授权（与401错误相    对），但是访问是被禁止的。<br>​    404 NOT FOUND - [</em>]：用户发出的请求针对的是不存在    的记录，服务器没有进行操作，该操作是幂等的。</p><p>​    405 Method Not Allowed:请求方法不被允许.</p><p>​    406 Not Acceptable - [GET]：用户请求的格式不对（比如    用户请求JS0ON格式，但是只有XML格式）。<br>​    410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。<br>​    422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对    象时，发生一个验证错误。<br>​    500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</p><h3 id="RESTFUL服务开发"><a href="#RESTFUL服务开发" class="headerlink" title="RESTFUL服务开发"></a>RESTFUL服务开发</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span><span class="comment">//controller+ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/emp1"</span>)</span><br><span class="line">Public <span class="class"><span class="keyword">class</span> <span class="title">RestController</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;/salary/&#123;date&#125;"</span>,method=RequestMethod.GET)</span><br><span class="line"><span class="meta">@ResponseBody</span><span class="comment">//有了RestController就不需要了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Salary <span class="title">xxxSalary</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id,@<span class="title">PathVariable</span><span class="params">(<span class="string">"date"</span>)</span>@<span class="title">DateTimeFormat</span><span class="params">(pattern=<span class="string">"yyyy-MM"</span>)</span>)</span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestBody把请求中的内容绑定到参数里面,使用Ajax方式提交的时候有用,提交的方式为”application/json”,表单的提交方式不用使用这个注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Ajax方式提交Content-Type就是application/json,这个时候需要使用@RequestBody进行处理</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">createEmp2</span><span class="params">(@RequestBody Employee employee)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"使用表单的方式提交创建"</span>);</span><br><span class="line"><span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@ResponseBody把响应中的内容绑定到参数里面</p><h5 id="RequestMapping中的参数-都可以是一个数组"><a href="#RequestMapping中的参数-都可以是一个数组" class="headerlink" title="RequestMapping中的参数(都可以是一个数组)"></a>RequestMapping中的参数(都可以是一个数组)</h5><h6 id="1-headers"><a href="#1-headers" class="headerlink" title="1.headers:"></a>1.headers:</h6><p>​    如果请求头(header)信息包含了规定的属性值(value),才会映射这个请求    headers=”header=value”</p><h6 id="2-produces"><a href="#2-produces" class="headerlink" title="2.produces:"></a>2.produces:</h6><p>​    定义返回值给客户端的 MIME 媒体类型,表示服务器映射的方法,是用于生产客户端需要的数据格式</p><p>​    prouces=”aaplication/xml;相当于请求头中包含headers=”Accept=value”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时相当于返回类型为application/json</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET,</span><br><span class="line">produces = <span class="string">"application/json"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpJson</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"json"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时相当于返回类型为application/xml</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.GET,</span><br><span class="line">produces = <span class="string">"application/xml"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getEmpXMl</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-consumes"><a href="#3-consumes" class="headerlink" title="3.consumes"></a>3.consumes</h6><p>​    表示用来指定表示可由资源消耗的 MIME 媒体类型</p><p>​    consumes=”application/x-www-form”相当于headers=”Content-Type=application/x-www-form”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此时接收的类型为application/x-www-form-urlencoded类型的</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST,</span><br><span class="line">consumes = <span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">createEmp</span><span class="params">(Employee employee)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"使用表单的方式提交创建"</span>);</span><br><span class="line"><span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时接收的类型为application/json类型的</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(method = RequestMethod.POST,</span><br><span class="line">consumes = <span class="string">"application/json"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Employee <span class="title">createEmp2</span><span class="params">(@RequestBody Employee employee)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"使用json的方式提交创建"</span>);</span><br><span class="line"><span class="keyword">return</span> employee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/web/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;作為一個人，要有獨立的思想和角
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="uncleyeung.github.io/2018/03/08/hello-world/"/>
    <id>uncleyeung.github.io/2018/03/08/hello-world/</id>
    <published>2018-03-08T14:28:25.000Z</published>
    <updated>2018-03-09T05:08:49.000Z</updated>
    
    <content type="html"><![CDATA[<script src="/web/assets/js/APlayer.min.js"> </script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS-Windows-macOS-and-Linux-app-amp-kernel-driver-dev-Patches-x86-64-assembly-on-the-side-Comp-Sci-Student"><a href="#作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS-Windows-macOS-and-Linux-app-amp-kernel-driver-dev-Patches-x86-64-assembly-on-the-side-Comp-Sci-Student" class="headerlink" title="作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS, Windows, macOS and Linux app &amp; kernel driver dev. Patches x86_64 assembly on the side. Comp Sci Student"></a>作為一個人，要有獨立的思想和角度去看待一個問題，而不只是盲目的跟風；iOS, Windows, macOS and Linux app &amp; kernel driver dev. Patches x86_64 assembly on the side. Comp Sci Student</h2><h3 id="TWITTER"><a href="#TWITTER" class="headerlink" title="TWITTER"></a><a href="https://twitter.com/uncleyeung" target="_blank" rel="noopener">TWITTER</a></h3><h2 id="你-好-师-姐"><a href="#你-好-师-姐" class="headerlink" title="你 好 师 姐"></a>你 好 师 姐</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.printl(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java的概述"><a href="#java的概述" class="headerlink" title="java的概述"></a>java的概述</h3><p>一种高级的开发语言.</p><h3 id="java三大平台"><a href="#java三大平台" class="headerlink" title="java三大平台"></a>java三大平台</h3><blockquote><ol><li>javaSE java的标准平台 (桌面平台)</li><li>javaEE java的企业级开发 (企业级应用&amp;银行系统)</li><li>javaME java微型平台 (嵌入式设备&amp;机顶盒&amp;还有以前的java小游戏之类)</li></ol></blockquote><h3 id="java的特性"><a href="#java的特性" class="headerlink" title="java的特性"></a>java的特性</h3><pre><code>最重要的一点是跨平台性.组织架构: jdk是最大的子集 包含运行环境jre 运行环境里又有jvm(虚拟机,也是跨平台的主要工具)</code></pre><blockquote><pre><code>1. 使用java语言编译源文件(和操作平台无关)2. 通过编译器(JavaC)编译产生字节码文件(class) 备注:和平台无关3. 启动java环境下的Jvm虚拟机,加载字节码文件(class)   ++注意 :这里的java虚拟机是不跨平台的++</code></pre></blockquote><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><pre><code>这里就不细讲了.</code></pre><h3 id="第一个java程序-Helloworld"><a href="#第一个java程序-Helloworld" class="headerlink" title="第一个java程序 Helloworld"></a>第一个java程序 Helloworld</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">java</span>                                 1.定义一个类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span>        2.定义一个系统主方法<span class="params">(每个java文件必须有主方法)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"helloworld"</span>);         <span class="number">3</span>.打印函数(结束语用分号;表示)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;                                                 <span class="number">4</span>.花括号,最大的结束符号</span><br></pre></td></tr></table></figure><h3 id="java开发的注意事项-重点"><a href="#java开发的注意事项-重点" class="headerlink" title="java开发的注意事项  重点 "></a>java开发的注意事项 <strong> 重点 </strong></h3><ol><li>拼写中严格区分大小写</li><li>一个源文件里可以定义多个类,并且产生多类名的class文件</li><li>若源文件有public类 文件名必须与类名同名</li><li>一个class文件可以定义多个类名但是只能有一个public定义的类名</li></ol><h3 id="java的基本语法"><a href="#java的基本语法" class="headerlink" title="java的基本语法"></a>java的基本语法</h3><blockquote><p>  1.注释类</p></blockquote><blockquote><pre><code>//     单行注释/* */  多行注释/** */ 文档注释</code></pre></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>多行注释和多行注释不能嵌套,文档注释和多行注释不能嵌套</p><blockquote><p>  2.分隔符号</p></blockquote><blockquote><pre><code>冒号: 分号; 大括号{} 数组符号[] 原点. 空格</code></pre></blockquote><blockquote><p>  3.关键字和保留字</p></blockquote><blockquote><p>   java实现规定的一个有<code>特殊含义</code>的<code>关键字</code>.</p></blockquote><blockquote><p>   <code>保留字</code>的意思是被事先设定, 但是暂时没有规定意思的值</p></blockquote><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><pre><code>1. 关键字和保留字都是小数组成的2. java无goto const 关键字</code></pre><blockquote><ol><li>标识符</li></ol></blockquote><h3 id="注意-2"><a href="#注意-2" class="headerlink" title="注意:"></a>注意:</h3><ol><li>由字母数字下划线$符号组成,但是  <code>不能用数字开头</code></li><li>大小写敏感,一般采用  <code>驼峰命名法</code></li><li>不能用  <code>系统里内置的类名</code></li><li>类名首字母要  <code>大写</code></li><li>中间不能有空格</li></ol><hr><h1 id="变量-常量-表达式"><a href="#变量-常量-表达式" class="headerlink" title="变量.常量.表达式"></a><code>变量.常量.表达式</code></h1><hr><blockquote><p>常量:固定不变的值<br>     整数常量(2L),小数常量(3.1),布尔型常量(boolean)</p></blockquote><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量:"></a><code>变量</code>:</h2><pre><code>开辟一块储存空间,存放一个不断变化的值</code></pre><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a><code>格式</code></h2><pre><code>int num = 15;char num = &apos;a&apos;;long num = 5L;boolean a = a&gt;b &amp; turn ;</code></pre><h2 id="变量的特点"><a href="#变量的特点" class="headerlink" title="变量的特点"></a><code>变量的特点</code></h2><pre><code>1.占据着内存的某一块空间2.该区域拥有自己的名称和数据类型3.可以被重复使用4.该区域的数值可以在同一类型的作用域内不断变化5.变量名的取名方法参考标识符,但是首字母要小写</code></pre><h2 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a><code>变量的分类</code></h2><pre><code>1.成员变量(全局变量):在主方法以外的变量2.局部变量:除了成员变量以外的变量都是局部变量</code></pre><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a><code>变量的作用域</code></h2><pre><code>成员变量:作用域作用域整个类.局部变量:变量名开始到第一个花括号结束.</code></pre><p><code>例如</code>:</p><pre><code>public class num{       int num1 = 1; // 成员变量    public static void main(String []args)    {        int num2 = 12;  // 局部变量    }}</code></pre><h2 id="变量的使用规则"><a href="#变量的使用规则" class="headerlink" title="变量的使用规则"></a><code>变量的使用规则</code></h2><pre><code>注意: 1.变量必须先声明,在初始化才可以使用,初始化的含义为赋值int num = 1;而非 int num ;成员(全局)变量自动默认初始化,局部变量必须初始化才可以生效    public class num{       static int num1; // 默认自动赋值    public static void main(String []args)    {        int num2 = 12;  // 先声明,在初始化    }}2.声明变量必须要有数据类型3.同一个作用域只能有一个变量名  int num = 12;  System.out.println(num);  //这样就会报错,两个一样的变量名  int num = 15;</code></pre><h2 id="变量的表达式"><a href="#变量的表达式" class="headerlink" title="变量的表达式"></a><code>变量的表达式</code></h2><pre><code>int a = 10;int b = 14;int c = 4;int d = 25;int num = (a + b + c - d) * a / 2;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;/web/assets/js/APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;作為一個人，要有獨立的思想和角
      
    
    </summary>
    
    
  </entry>
  
</feed>
